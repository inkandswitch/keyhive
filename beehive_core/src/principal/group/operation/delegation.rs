// FIXME move opetaion to same level
use super::revocation::Revocation;
use crate::{
    access::Access, crypto::hash::Hash, crypto::signed::Signed, principal::agent::Agent,
    principal::document::Document,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Delegation<'a, T: std::hash::Hash + Clone> {
    pub can: Access,

    pub proof: Option<&'a Signed<Delegation<'a, T>>>,
    pub delegate: &'a Agent<'a, T>,

    pub after_revocations: Vec<&'a Signed<Revocation<'a, T>>>,
    pub after_content: Vec<(&'a Document<'a, T>, Hash<T>)>,
}

impl<'a, T: std::hash::Hash + Clone> From<Delegation<'a, T>> for Vec<u8> {
    fn from(delegation: Delegation<'a, T>) -> Vec<u8> {
        // FIXME autogenerated
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&delegation.subject.to_bytes());
        // FIXME! bytes.extend_from_slice(&delegation.can.to_bytes());
        bytes.extend_from_slice(&delegation.from.to_bytes());
        // FIXME!
        // bytes.extend_from_slice(&delegation.proof.iter().fold(Vec::new(), |mut acc, hash| {
        //     acc.extend_from_slice(&hash.to_bytes());
        //     acc
        // }));
        // FIXME bytes.extend_from_slice(&delegation.to.to_bytes());
        // FIXME
        // bytes.extend_from_slice(
        //     &delegation
        //         .after_auth
        //         .iter()
        //         .fold(Vec::new(), |mut acc, hash| {
        //             acc.extend_from_slice(&hash.to_bytes());
        //             acc
        //         }),
        // );
        bytes
    }
}
